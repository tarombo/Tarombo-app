--- a/app/src/main/java/app/familygem/Diagram.java
+++ b/app/src/main/java/app/familygem/Diagram.java
@@ -156,7 +156,7 @@ public class Diagram extends Fragment {
 					startActivity(new Intent(getContext(), DiagramSettings.class));
 					break;
 				case 1: // Share diagram
-					CharSequence[] shareFormats = {getText(R.string.pdf), getText(R.string.jpeg)};
+					CharSequence[] shareFormats = {getText(R.string.pdf), getText(R.string.jpeg), getText(R.string.text)};
 					new AlertDialog.Builder(getContext())
 							.setTitle(R.string.choose_format)
 							.setItems(shareFormats, (dialog, which) -> {
@@ -167,11 +167,14 @@ public class Diagram extends Fragment {
 									case 1: // Share as JPEG
 										shareDiagramAsJPEG();
 										break;
+									case 2: // Share as Text
+										shareDiagramAsText();
+										break;
 								}
 							}).show();
 					break;
 				case 2: // Export diagram
-					CharSequence[] exportFormats = {getText(R.string.pdf), getText(R.string.jpeg)};
+					CharSequence[] exportFormats = {getText(R.string.pdf), getText(R.string.jpeg), getText(R.string.text)};
 					new AlertDialog.Builder(getContext())
 							.setTitle(R.string.choose_format)
 							.setItems(exportFormats, (dialog, which) -> {
@@ -182,6 +185,9 @@ public class Diagram extends Fragment {
 									case 1: // Export as JPEG
 										F.salvaDocumento(null, this, Global.settings.openTree, "image/jpeg", "jpg", 905);
 										break;
+									case 2: // Export as Text
+										F.salvaDocumento(null, this, Global.settings.openTree, "text/plain", "txt", 906);
+										break;
 								}
 							}).show();
 					break;
@@ -1270,6 +1276,19 @@ public class Diagram extends Fragment {
 					return;
 				}
 				Toast.makeText(getContext(), R.string.jpeg_exported_ok, Toast.LENGTH_LONG).show();
+			} // Export diagram to Text
+			else if( requestCode == 906 ) {
+				Uri uri = data.getData();
+				try {
+					String textContent = generateFamilyTreeText();
+					OutputStream out = getContext().getContentResolver().openOutputStream(uri, "wt");
+					out.write(textContent.getBytes("UTF-8"));
+					out.flush();
+					out.close();
+					Toast.makeText(getContext(), R.string.text_exported_ok, Toast.LENGTH_LONG).show();
+				} catch( Exception e ) {
+					Toast.makeText(getContext(), e.getLocalizedMessage(), Toast.LENGTH_LONG).show();
+				}
 			} // Search person
 			else if( requestCode == 904 ) {
 				String selectedPersonId = data.getStringExtra("selectedPersonId");
@@ -1394,6 +1413,196 @@ public class Diagram extends Fragment {
 		}
 	}
 
+	/**
+	 * Share diagram as Text through Android share sheet
+	 */
+	private void shareDiagramAsText() {
+		try {
+			// Generate text representation
+			String textContent = generateFamilyTreeText();
+
+			// Write Text to temp file
+			File cacheDir = new File(getContext().getCacheDir(), "shared");
+			cacheDir.mkdirs();
+			String treeTitle = Global.settings.getTree(Global.settings.openTree).title.replaceAll("[$']", "_");
+			File textFile = new File(cacheDir, treeTitle + ".txt");
+			
+			FileOutputStream fos = new FileOutputStream(textFile);
+			fos.write(textContent.getBytes("UTF-8"));
+			fos.flush();
+			fos.close();
+
+			// Get URI and share
+			Uri textUri = androidx.core.content.FileProvider.getUriForFile(
+					getContext(),
+					getContext().getPackageName() + ".provider",
+					textFile);
+
+			Intent shareIntent = new Intent(Intent.ACTION_SEND);
+			shareIntent.setType("text/plain");
+			shareIntent.putExtra(Intent.EXTRA_STREAM, textUri);
+			shareIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+			startActivity(Intent.createChooser(shareIntent, getText(R.string.share_diagram)));
+
+		} catch (Exception e) {
+			Toast.makeText(getContext(), e.getLocalizedMessage(), Toast.LENGTH_LONG).show();
+		}
+	}
+
+	/**
+	 * Generate text representation of the family tree
+	 */
+	private String generateFamilyTreeText() {
+		StringBuilder sb = new StringBuilder();
+		Settings.Tree tree = Global.settings.getTree(Global.settings.openTree);
+		sb.append(tree.title).append("\n");
+		// Create equals line (Java 8 compatible)
+		for (int i = 0; i < tree.title.length(); i++) {
+			sb.append("=");
+		}
+		sb.append("\n\n");
+
+		// Start from the current person (fulcrum)
+		Person fulcrumPerson = gc.getPerson(Global.indi);
+		if (fulcrumPerson != null) {
+			sb.append(getString(R.string.diagram_of)).append(": ");
+			sb.append(U.epiteto(fulcrumPerson)).append("\n\n");
+			generateFamilyTreeTextRecursive(fulcrumPerson, sb, 0, new java.util.HashSet<String>());
+		} else {
+			sb.append(getString(R.string.no_persons)).append("\n");
+		}
+
+		return sb.toString();
+	}
+
+	/**
+	 * Recursively generate text representation of family members
+	 */
+	private void generateFamilyTreeTextRecursive(Person person, StringBuilder sb, int level, Set<String> visited) {
+		if (person == null || visited.contains(person.getId())) {
+			return;
+		}
+		visited.add(person.getId());
+
+		// Create indentation (Java 8 compatible)
+		StringBuilder indentBuilder = new StringBuilder();
+		for (int i = 0; i < level; i++) {
+			indentBuilder.append("  ");
+		}
+		String indent = indentBuilder.toString();
+
+		// Person info
+		sb.append(indent);
+		if (level > 0) {
+			sb.append("├─ "); // ├─
+		}
+		sb.append(U.epiteto(person));
+
+		// Birth and death dates
+		String dates = U.twoDates(person, false);
+		if (dates != null && !dates.isEmpty()) {
+			sb.append(" (").append(dates).append(")");
+		}
+		sb.append("\n");
+
+		// Spouses and children
+		List<Family> spouseFamilies = person.getSpouseFamilies(gc);
+		if (spouseFamilies != null) {
+			for (Family family : spouseFamilies) {
+				// Find spouse
+				Person spouse = null;
+				if (family.getHusbandRefs() != null && person.getSpouseFamilyRefs() != null) {
+					for (org.folg.gedcom.model.SpouseFamilyRef ref : person.getSpouseFamilyRefs()) {
+						if (ref.getRef().equals(family.getId())) {
+							for (org.folg.gedcom.model.SpouseRef husbandRef : family.getHusbandRefs()) {
+								Person husband = gc.getPerson(husbandRef.getRef());
+								if (husband != null && !husband.getId().equals(person.getId())) {
+									spouse = husband;
+									break;
+								}
+							}
+						}
+					}
+				}
+				if (spouse == null && family.getWifeRefs() != null && person.getSpouseFamilyRefs() != null) {
+					for (org.folg.gedcom.model.SpouseFamilyRef ref : person.getSpouseFamilyRefs()) {
+						if (ref.getRef().equals(family.getId())) {
+							for (org.folg.gedcom.model.SpouseRef wifeRef : family.getWifeRefs()) {
+								Person wife = gc.getPerson(wifeRef.getRef());
+								if (wife != null && !wife.getId().equals(person.getId())) {
+									spouse = wife;
+									break;
+								}
+							}
+						}
+					}
+				}
+
+				if (spouse != null && !visited.contains(spouse.getId())) {
+					sb.append(indent).append("  ");
+					sb.append("⚭ ").append(U.epiteto(spouse)); // ⚭
+					String spouseDates = U.twoDates(spouse, false);
+					if (spouseDates != null && !spouseDates.isEmpty()) {
+						sb.append(" (").append(spouseDates).append(")");
+					}
+					sb.append("\n");
+				}
+
+				// Children
+				if (family.getChildRefs() != null) {
+					for (org.folg.gedcom.model.ChildRef childRef : family.getChildRefs()) {
+						Person child = gc.getPerson(childRef.getRef());
+						if (child != null && !visited.contains(child.getId())) {
+							generateFamilyTreeTextRecursive(child, sb, level + 1, visited);
+						}
+					}
+				}
+			}
+		}
+
+		// Parents (only for the root person)
+		if (level == 0 && person.getParentFamilyRefs() != null) {
+			for (org.folg.gedcom.model.ParentFamilyRef parentFamilyRef : person.getParentFamilyRefs()) {
+				Family parentFamily = gc.getFamily(parentFamilyRef.getRef());
+				if (parentFamily != null) {
+					sb.append("\n").append(getString(R.string.parents)).append(":\n");
+					
+					// Father
+					if (parentFamily.getHusbandRefs() != null) {
+						for (org.folg.gedcom.model.SpouseRef husbandRef : parentFamily.getHusbandRefs()) {
+							Person father = gc.getPerson(husbandRef.getRef());
+							if (father != null) {
+								sb.append("  ├─ ").append(getString(R.string.father)).append(": ");
+								sb.append(U.epiteto(father));
+								String fatherDates = U.twoDates(father, false);
+								if (fatherDates != null && !fatherDates.isEmpty()) {
+									sb.append(" (").append(fatherDates).append(")");
+								}
+								sb.append("\n");
+							}
+						}
+					}
+					
+					// Mother
+					if (parentFamily.getWifeRefs() != null) {
+						for (org.folg.gedcom.model.SpouseRef wifeRef : parentFamily.getWifeRefs()) {
+							Person mother = gc.getPerson(wifeRef.getRef());
+							if (mother != null) {
+								sb.append("  ├─ ").append(getString(R.string.mother)).append(": ");
+								sb.append(U.epiteto(mother));
+								String motherDates = U.twoDates(mother, false);
+								if (motherDates != null && !motherDates.isEmpty()) {
+									sb.append(" (").append(motherDates).append(")");
+								}
+								sb.append("\n");
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
 	/**
 	 * open the tree if it already exists locally, or
 	 * subscribe if it is not subscribed yet, then open, or
